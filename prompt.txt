---
name: telegram-clipboard-to-template-markdown
overview: –î–æ–±–∞–≤–∏—Ç—å –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä —à–∞–±–ª–æ–Ω–æ–≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∏–∑ Telegram clipboard (application/x-td-field-text + application/x-td-field-tags) –≤ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –ø—Å–µ–≤–¥–æ‚Äëmarkdown —Ñ–æ—Ä–º–∞—Ç –ø–æ—Å—Ç–æ–≤.
todos:
  - id: extract-tag-parser
    content: –í—ã–Ω–µ—Å—Ç–∏ –ø–∞—Ä—Å–µ—Ä –±–∏–Ω–∞—Ä–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ application/x-td-field-tags –≤ –æ—Ç–¥–µ–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é/—Å—Ç—Ä—É–∫—Ç—É—Ä—É –∏ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å –≤ TelegramFormatter
    status: pending
  - id: implement-reverse-markdown
    content: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∏–∑ cleanText + TagRecord –≤ –ø—Å–µ–≤–¥–æ‚Äëmarkdown —Å—Ç—Ä–æ–∫—É (–æ–±—Ä–∞—Ç–Ω–æ–µ –∫ —Ç–µ–∫—É—â–µ–º—É TelegramFormatter)
    status: pending
  - id: hook-template-editor-paste
    content: –ü–µ—Ä–µ—Ö–≤–∞—Ç–∏—Ç—å –≤—Å—Ç–∞–≤–∫—É –≤ –ø–æ–ª—è—Ö Telegram-–ø–æ—Å—Ç–æ–≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ —à–∞–±–ª–æ–Ω–æ–≤ –∏ –≤—ã–∑—ã–≤–∞—Ç—å –æ–±—Ä–∞—Ç–Ω—ã–π –ø–∞—Ä—Å–µ—Ä —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ Telegram MIME-—Ç–∏–ø–æ–≤
    status: pending
  - id: test-on-real-telegram-data
    content: –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Å—Ç–∞–≤–∫—É –ø–æ—Å—Ç–æ–≤ —Å custom emoji, —Å—Å—ã–ª–∫–∞–º–∏ –∏ —Å—Ç–∏–ª—è–º–∏ –∏–∑ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞ Telegram –∏ —É–±–µ–¥–∏—Ç—å—Å—è –≤ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–º–æ—Å—Ç–∏ —Ñ–æ—Ä–º–∞—Ç–∞
    status: pending
isProject: false
---

### –¶–µ–ª–∏

- **–°—á–∏—Ç–∞—Ç—å Telegram-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–π –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞** (`application/x-td-field-text` –∏ `application/x-td-field-tags`) –ø—Ä–∏ –≤—Å—Ç–∞–≤–∫–µ –≤ –ø–æ–ª—è —à–∞–±–ª–æ–Ω–æ–≤ –ø–æ—Å—Ç–æ–≤.
- **–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤—ã–≤–∞—Ç—å —Ñ–æ—Ä–º–∞—Ç Telegram –æ–±—Ä–∞—Ç–Ω–æ –≤ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –ø—Å–µ–≤–¥–æ‚Äëmarkdown** (—Ç–æ—Ç –∂–µ, –∫–æ—Ç–æ—Ä—ã–π —Å–µ–π—á–∞—Å `TelegramFormatter` –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç –≤ Telegram-—Ä–∞–∑–º–µ—Ç–∫—É).
- **–°–æ—Ö—Ä–∞–Ω—è—Ç—å –ø–æ–≤–µ–¥–µ–Ω–∏–µ –æ–±—ã—á–Ω–æ–π –≤—Å—Ç–∞–≤–∫–∏**: –µ—Å–ª–∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö MIME-—Ç–∏–ø–æ–≤ Telegram –Ω–µ—Ç, –≤—Å—Ç–∞–≤–ª—è—Ç—å –æ–±—ã—á–Ω—ã–π plaintext –∫–∞–∫ —Å–µ–π—á–∞—Å.

### –®–∞–≥ 1. –ò–Ω–∫–∞–ø—Å—É–ª–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–∑–±–æ—Ä –±–∏–Ω–∞—Ä–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ —Ç–µ–≥–æ–≤

- **–°–æ–∑–¥–∞—Ç—å –Ω–µ–±–æ–ª—å—à–æ–π –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –º–æ–¥—É–ª—å/–∫–ª–∞—Å—Å**, –Ω–∞–ø—Ä–∏–º–µ—Ä `TelegramTagParser` –≤ `[src/processing/telegramformatter.cpp](src/processing/telegramformatter.cpp)` –∏–ª–∏ –æ—Ç–¥–µ–ª—å–Ω–æ–º —Ñ–∞–π–ª–µ —Ä—è–¥–æ–º.
  - –í—ã–Ω–µ—Å—Ç–∏ —Ç—É–¥–∞ –ª–æ–≥–∏–∫—É —Ä–∞–∑–±–æ—Ä–∞ `application/x-td-field-tags`, –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å —É–∂–µ –∑–∞–¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —Ñ–æ—Ä–º–∞—Ç–æ–º –∏–∑ `[.cursor/telegram_clipboard_tags_format.md](.cursor/telegram_clipboard_tags_format.md)`:
    - `u32 count;` –∑–∞—Ç–µ–º `count` –∑–∞–ø–∏—Å–µ–π –ø–æ 3√ó`u32` + UTF‚Äë16 BE —Å—Ç—Ä–æ–∫–∞.
  - –í–µ—Ä–Ω—É—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –≤–∏–¥–∞ `struct TagRecord { qsizetype position; qsizetype length; QStringList tokens; };` –≥–¥–µ `tokens` ‚Äî `tagContent.split("\\")` (–Ω–∞–ø—Ä–∏–º–µ—Ä, `"**"`, `"custom-emoji://‚Ä¶"`, `"https://‚Ä¶"`).
- **–î–æ–±–∞–≤–∏—Ç—å –ø—É–±–ª–∏—á–Ω—ã–π helper** –≤ `TelegramFormatter`, –Ω–∞–ø—Ä–∏–º–µ—Ä:
  - `static QString fromTelegramClipboardToPseudoMarkdown(const QMimeData *mime);`
  - –û–Ω –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `mime->data("application/x-td-field-text")` –∏ `mime->data("application/x-td-field-tags")` + `TelegramTagParser`.

### –®–∞–≥ 2. –ê–ª–≥–æ—Ä–∏—Ç–º –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –≤ –ø—Å–µ–≤–¥–æ‚Äëmarkdown

- **–ò–∑–≤–ª–µ—á—å –∏—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç**:
  - –ï—Å–ª–∏ –µ—Å—Ç—å `application/x-td-field-text` ‚Üí –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ –∫–∞–∫ `cleanText` (UTF‚Äë8).
  - –ò–Ω–∞—á–µ fallback –Ω–∞ `text/plain` (–≤ —ç—Ç–æ–º —Å–ª—É—á–∞–µ Telegram-—Ç–µ–≥–æ–≤ –º–æ–∂–µ—Ç –Ω–µ –±—ã—Ç—å, –∏ –º—ã –ø—Ä–æ—Å—Ç–æ –≤–µ—Ä–Ω—ë–º —ç—Ç–æ—Ç —Ç–µ–∫—Å—Ç –∫–∞–∫ –µ—Å—Ç—å).
- **–†–∞–∑–±–∏—Ç—å —Ç–µ–∫—Å—Ç –Ω–∞ —Å–µ–≥–º–µ–Ω—Ç—ã –ø–æ —Ç–µ–≥–∞–º**:
  - –ù–∞ –æ—Å–Ω–æ–≤–µ `TagRecord` —Å–æ–±—Ä–∞—Ç—å –≤—Å–µ –≥—Ä–∞–Ω–∏—á–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏: `0`, `cleanText.size()`, `position` –∏ `position+length` –∫–∞–∂–¥–æ–≥–æ —Ç–µ–≥–∞.
  - –û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∏ —É–¥–∞–ª–∏—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã ‚Üí –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã `[b[i], b[i+1])`.
  - –î–ª—è –∫–∞–∂–¥–æ–≥–æ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å **–∞–∫—Ç—É–∞–ª—å–Ω—ã–π –Ω–∞–±–æ—Ä —Ç–æ–∫–µ–Ω–æ–≤** ‚Äî –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ `tokens` –≤—Å–µ—Ö `TagRecord`, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø–æ–∫—Ä—ã–≤–∞—é—Ç —ç—Ç–æ—Ç –∏–Ω—Ç–µ—Ä–≤–∞–ª (`position <= b[i] && position+length >= b[i+1]`).
- **–ò–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–≥–∏ –≤ –ø—Å–µ–≤–¥–æ‚Äëmarkdown –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞**:
  - –ü–æ–ª—É—á–∏—Ç—å –ø–æ–¥—Å—Ç—Ä–æ–∫—É `segment = cleanText.mid(b[i], b[i+1] - b[i])`.
  - –†–∞–∑–¥–µ–ª–∏—Ç—å —Ç–æ–∫–µ–Ω—ã –Ω–∞ –≥—Ä—É–ø–ø—ã:
    - `styleTokens` = `**`, `__`, `~~`, `||`, `^^`, ```.
    - `quoteTokens` = `>` –∏–ª–∏ `>^` (–µ—Å–ª–∏ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—Ç).
    - `linkToken` = –µ—Å–ª–∏ –µ—Å—Ç—å URL —Ç–∏–ø–∞ `https://‚Ä¶`.
    - `emojiToken` = `custom-emoji://<id>?<size>`.
  - **Custom emoji**:
    - –î–ª—è `emojiToken` —Ä–∞–∑–±—Ä–∞—Ç—å `idWithSize` –∏, –µ—Å–ª–∏ –µ—Å—Ç—å, `?size`.
    - –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –±–∞–∑–æ–≤—ã–π –º–∞—Ä–∫–µ—Ä: `core = QString("[%1](emoji:%2)").arg(segment, idWithSize);`.
  - **–°—Å—ã–ª–∫–∏**:
    - –ï—Å–ª–∏ –µ—Å—Ç—å `linkToken` –∏ `segment` ‚Äî —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å `[segment](<url>)`.
  - **–ù–∞–ª–æ–∂–∏—Ç—å —Å—Ç–∏–ª–∏**:
    - –î–ª—è `styleTokens` –æ–±–µ—Ä–Ω—É—Ç—å `core` –∏–ª–∏ `segment` –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å —Ç–µ–∫—É—â–µ–π —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ–º:
      - `**` ‚Üí `"**" + text + "**"`, `__` ‚Üí `"__" + text + "__"` –∏ —Ç.–¥.
      - –ü—Ä–∏ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å—Ç–∏–ª–µ–π –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ (–Ω–∞–ø—Ä–∏–º–µ—Ä, `code` ‚Üí `bold` ‚Üí `underline` ‚Üí `strike` ‚Üí `spoiler` ‚Üí `sup`).
  - **–¶–∏—Ç–∞—Ç—ã**:
    - –ï—Å–ª–∏ –µ—Å—Ç—å `>` ‚Üí –æ–±–µ—Ä–Ω—É—Ç—å –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ `">" + text + "<"`.
    - –ï—Å–ª–∏ –µ—Å—Ç—å `>^` ‚Üí `">^" + text + "<^"`.
  - –ï—Å–ª–∏ —Ç–æ–∫–µ–Ω–æ–≤ –Ω–µ—Ç ‚Äî –≤–µ—Ä–Ω—É—Ç—å `segment` –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π.
- **–°–æ–±—Ä–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç** –∫–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏–µ–π –≤—Å–µ—Ö –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–µ–≥–º–µ–Ω—Ç–æ–≤ –≤ –∏—Å—Ö–æ–¥–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ.

### –®–∞–≥ 3. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Ä–µ–¥–∞–∫—Ç–æ—Ä–æ–º —à–∞–±–ª–æ–Ω–æ–≤ (`TemplateEditor`)

- –í `[src/ui/templateeditor.cpp](src/ui/templateeditor.cpp)` –∏ `[ui/templateeditor.ui](ui/templateeditor.ui)`:
  - **–ù–∏—á–µ–≥–æ –Ω–µ –ª–æ–º–∞—Ç—å –≤ —Ç–µ–∫—É—â–µ–º UX**, –¥–æ–±–∞–≤–∏—Ç—å "—É–º–Ω—ã–π" –ø—É—Ç—å –≤—Å—Ç–∞–≤–∫–∏:
    - –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≤—Å—Ç–∞–≤–∫—É –¥–ª—è –ø–æ–ª–µ–π `postTgMp4Edit` –∏ `postTgMkvEdit` (–ø–æ–¥–∫–ª–∞—Å—Å `QPlainTextEdit` –∏–ª–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ `insertFromMimeData` —á–µ—Ä–µ–∑ –∫–∞—Å—Ç–æ–º–Ω—ã–π –≤–∏–¥–∂–µ—Ç/–¥–µ–ª–µ–≥–∞—Ç).
    - –í–Ω—É—Ç—Ä–∏ `insertFromMimeData(const QMimeData *source)`:
      - –ï—Å–ª–∏ `source->hasFormat("application/x-td-field-text")` –∏ `source->hasFormat("application/x-td-field-tags")` ‚Üí –≤—ã–∑–≤–∞—Ç—å `TelegramFormatter::fromTelegramClipboardToPseudoMarkdown(source)` –∏ –≤—Å—Ç–∞–≤–∏—Ç—å –ø–æ–ª—É—á–µ–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É **–≤–º–µ—Å—Ç–æ** —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –ª–æ–≥–∏–∫–∏.
      - –ò–Ω–∞—á–µ –≤—ã–∑–≤–∞—Ç—å –±–∞–∑–æ–≤—É—é —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é `QPlainTextEdit::insertFromMimeData(source)` (–æ–±—ã—á–Ω–∞—è –≤—Å—Ç–∞–≤–∫–∞ plaintext/RTF –∏ —Ç.–ø.).
- –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ, –µ—Å–ª–∏ –Ω–µ —Ö–æ—á–µ—Ç—Å—è –ª–µ–∑—Ç—å –≤ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ:
  - –î–æ–±–∞–≤–∏—Ç—å —Ä—è–¥–æ–º —Å –ø–æ–ª—è–º–∏ –∫–Ω–æ–ø–∫–∏ "–í—Å—Ç–∞–≤–∏—Ç—å –∏–∑ Telegram" –∏ –≤ —Å–ª–æ—Ç–∞—Ö –¥–µ–ª–∞—Ç—å:
    ```cpp
    const QMimeData *mime = QGuiApplication::clipboard()->mimeData();
    const QString md = TelegramFormatter::fromTelegramClipboardToPseudoMarkdown(mime);
    ui->postTgMp4Edit->setPlainText(md);
    ```
  - –ù–æ –ø–æ —Ç–≤–æ–µ–º—É –æ–ø–∏—Å–∞–Ω–∏—é –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–µ–µ –∏–º–µ–Ω–Ω–æ –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞—Ç—å –≤—Å—Ç–∞–≤–∫—É, –µ—Å–ª–∏ –≤ –±—É—Ñ–µ—Ä–µ –µ—Å—Ç—å Telegram-—Ñ–æ—Ä–º–∞—Ç—ã.

### –®–∞–≥ 4. –¢–µ—Å—Ç—ã –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è

- **–°–æ–±—Ä–∞—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã**:
  - –ü–æ—Å—Ç —Å:
    - –æ–¥–Ω–∏–º custom emoji,
    - –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ custom emoji,
    - –∫–æ–º–±–∏–Ω–∞—Ü–∏–µ–π —Å—Ç–∏–ª–∏–∑–∞—Ü–∏–∏ (–∂–∏—Ä–Ω—ã–π + custom emoji + —Å—Å—ã–ª–∫–∞),
    - —Ü–∏—Ç–∞—Ç–∞–º–∏ `>` –∏ `>^`.
  - –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∏–∑ –Ω–∞—Å—Ç–æ—è—â–µ–≥–æ Telegram-–∫–ª–∏–µ–Ω—Ç–∞ ‚Üí –≤—Å—Ç–∞–≤–∏—Ç—å –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä —à–∞–±–ª–æ–Ω–æ–≤ ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ:
    - –ü–æ—è–≤–∏–ª—Å—è –ø—Å–µ–≤–¥–æ‚Äëmarkdown (–Ω–∞–ø—Ä–∏–º–µ—Ä, `[üíô](emoji:documentId?size)`),
    - –ü—Ä–∏ –ø–æ—Å–ª–µ–¥—É—é—â–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ —Ç–µ–∫—É—â–µ–≥–æ `TelegramFormatter::formatAndCopyToClipboard` —Ñ–æ—Ä–º–∞—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è –≤ Telegram (custom emoji, —Å—Å—ã–ª–∫–∏, —Å—Ç–∏–ª–∏).
- –ü—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –¥–æ–±–∞–≤–∏—Ç—å –Ω–µ–±–æ–ª—å—à–æ–π unit-—Ç–µ—Å—Ç –Ω–∞ –ø–∞—Ä—Å–µ—Ä —Ç–µ–≥–æ–≤ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º —Ç–∞—Ä–≥–µ—Ç–µ (–∏–ª–∏ —Ö–æ—Ç—è –±—ã –æ—Ç–ª–∞–¥–æ—á–Ω—ã–π helper, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ –≤—ã–∑—ã–≤–∞—Ç—å –≤—Ä—É—á–Ω—É—é).

### –®–∞–≥ 5. –†–∞—Å—à–∏—Ä–µ–Ω–∏—è

- –î–æ–±–∞–≤–∏—Ç—å **–æ—Ç–ª–∞–¥–æ—á–Ω–æ–µ –æ–∫–Ω–æ**/–ª–æ–≥–≥–µ—Ä –≤ dev-—Å–±–æ—Ä–∫–µ, —á—Ç–æ–±—ã —Å–º–æ—Ç—Ä–µ—Ç—å —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω–Ω—ã–µ `TagRecord` –∏ –ø–æ—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –ø—Å–µ–≤–¥–æ‚Äëmarkdown –ø—Ä–∏ –≤—Å—Ç–∞–≤–∫–µ.


–ø–µ—Ä–≤–∞—è –ø–æ–ø—ã—Ç–∫–∞ —Ä–µ–∞–ª–∏–∑–∞–∏–∏
#ifndef TELEGRAMFORMATTER_H
#define TELEGRAMFORMATTER_H

#include <QString>

class QMimeData;

class TelegramFormatter
{
public:
    // –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è, –∫–æ—Ç–æ—Ä—É—é –±—É–¥–µ–º –≤—ã–∑—ã–≤–∞—Ç—å —Å–Ω–∞—Ä—É–∂–∏
    static void formatAndCopyToClipboard(const QString& markdownText);

    // –û–±—Ä–∞—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ: –∏–∑ Telegram-–±—É—Ñ–µ—Ä–∞ –æ–±–º–µ–Ω–∞ (application/x-td-field-*)
    // –≤ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –ø—Å–µ–≤–¥–æ-markdown —Ñ–æ—Ä–º–∞—Ç.
    static QString fromTelegramClipboardToPseudoMarkdown(const QMimeData* mimeData);
};

#endif // TELEGRAMFORMATTER_H

#include "telegramformatter.h"

#include <QClipboard>
#include <QDataStream>
#include <QGuiApplication>
#include <QIODevice>
#include <QList>
#include <QMap>
#include <QMimeData>
#include <QPair>
#include <QRegularExpression>
#include <QSet>
#include <algorithm>

struct FinalTag
{
    qsizetype position;
    qsizetype length;
    QString tagData;
    bool operator<(const FinalTag& other) const
    {
        return position < other.position;
    }
};

struct MatchInfo
{
    qsizetype start;
    qsizetype length;
    QString content;
    QString tag;
};

namespace
{

struct TagRecord
{
    qsizetype position{};
    qsizetype length{};
    QString tagContent; // —É–∂–µ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω–∞—è UTF-16 BE —Å—Ç—Ä–æ–∫–∞
};

QPair<QString, QList<FinalTag>> parseText(const QString& text, const QList<QPair<QRegularExpression, QString>>& rules)
{
    QString cleanText;
    QList<FinalTag> tags;

    QList<MatchInfo> allMatches;
    for (const auto& rulePair : rules)
    {
        auto it = rulePair.first.globalMatch(text);
        while (it.hasNext())
        {
            QRegularExpressionMatch match = it.next();
            if (rulePair.second == "code-block")
            {
                QString lang = match.captured(1);
                QString code = match.captured(2);
                allMatches.append({match.capturedStart(0), match.capturedLength(0), code, "```" + lang});
            }
            else if (rulePair.second == "custom-emoji")
            {
                allMatches.append({match.capturedStart(0), match.capturedLength(0), match.captured(1),
                                   "custom-emoji://" + match.captured(2)});
            }
            else if (rulePair.second == "link")
            {
                allMatches.append(
                    {match.capturedStart(0), match.capturedLength(0), match.captured(1), match.captured(2)});
            }
            else
            {
                allMatches.append(
                    {match.capturedStart(0), match.capturedLength(0), match.captured(1), rulePair.second});
            }
        }
    }

    QList<MatchInfo> topLevelMatches;
    for (const auto& matchA : allMatches)
    {
        bool isNested = false;
        for (const auto& matchB : allMatches)
        {
            if (&matchA == &matchB)
            {
                continue;
            }
            if (matchA.start >= matchB.start && (matchA.start + matchA.length) <= (matchB.start + matchB.length))
            {
                isNested = true;
                break;
            }
        }
        if (!isNested)
        {
            topLevelMatches.append(matchA);
        }
    }
    std::sort(topLevelMatches.begin(), topLevelMatches.end(),
              [](const auto& a, const auto& b) { return a.start < b.start; });

    qsizetype lastPos = 0;
    for (const auto& match : topLevelMatches)
    {
        cleanText.append(text.mid(lastPos, match.start - lastPos));

        QPair<QString, QList<FinalTag>> subResult;
        if (match.tag.startsWith("```"))
        {
            subResult.first = match.content;
        }
        else if (match.tag == ">" || match.tag == ">^")
        {
            QList<QPair<QRegularExpression, QString>> quoteRules = rules;
            quoteRules.removeIf([](const auto& rule) { return rule.second == "`"; });
            subResult = parseText(match.content, quoteRules);
        }
        else
        {
            subResult = parseText(match.content, rules);
        }

        qsizetype parentTagStartPos = cleanText.length();
        cleanText.append(subResult.first);

        qsizetype lastTaggedPosInSub = 0;
        std::sort(subResult.second.begin(), subResult.second.end());

        for (auto& subTag : subResult.second)
        {
            if (subTag.position > lastTaggedPosInSub)
            {
                tags.append({parentTagStartPos + lastTaggedPosInSub, subTag.position - lastTaggedPosInSub, match.tag});
            }
            QStringList combined = subTag.tagData.split('\\');
            combined.append(match.tag);
            std::sort(combined.begin(), combined.end());
            subTag.tagData = combined.join('\\');
            tags.append({parentTagStartPos + subTag.position, subTag.length, subTag.tagData});
            lastTaggedPosInSub = subTag.position + subTag.length;
        }
        if (lastTaggedPosInSub < subResult.first.length())
        {
            tags.append(
                {parentTagStartPos + lastTaggedPosInSub, subResult.first.length() - lastTaggedPosInSub, match.tag});
        }
        if (subResult.second.isEmpty() && !subResult.first.isEmpty())
        {
            tags.append({parentTagStartPos, subResult.first.length(), match.tag});
        }

        lastPos = match.start + match.length;
    }
    cleanText.append(text.mid(lastPos));

    return {cleanText, tags};
}

QVector<TagRecord> parseTelegramTagsBinary(const QByteArray& bytes)
{
    QVector<TagRecord> result;
    if (bytes.size() < static_cast<int>(sizeof(quint32)))
    {
        return result;
    }

    QDataStream stream(bytes);
    stream.setByteOrder(QDataStream::BigEndian);

    quint32 count = 0;
    stream >> count;

    for (quint32 i = 0; i < count && !stream.atEnd(); ++i)
    {
        quint32 pos = 0;
        quint32 len = 0;
        quint32 size = 0;
        stream >> pos >> len >> size;

        if (stream.status() != QDataStream::Ok || size == 0)
        {
            break;
        }

        QByteArray utf16Data(size, Qt::Uninitialized);
        const int kActuallyRead = stream.readRawData(utf16Data.data(), static_cast<int>(size));
        if (kActuallyRead != static_cast<int>(size))
        {
            break;
        }

        const auto* u16 = reinterpret_cast<const char16_t*>(utf16Data.constData());
        const int kU16Length = utf16Data.size() / 2;
        QString tagContent = QString::fromUtf16(u16, kU16Length);

        TagRecord rec;
        rec.position = static_cast<qsizetype>(pos);
        rec.length = static_cast<qsizetype>(len);
        rec.tagContent = tagContent;
        result.append(rec);
    }

    return result;
}

QString applyTokensToSegment(const QString& segment, const QStringList& tokens)
{
    if (segment.isEmpty())
    {
        return segment;
    }

    // –†–∞–∑–±–∏—Ä–∞–µ–º —Ç–æ–∫–µ–Ω—ã –ø–æ —Ç–∏–ø–∞–º
    bool hasBold = false;
    bool hasUnderline = false;
    bool hasStrike = false;
    bool hasSpoiler = false;
    bool hasSup = false;
    bool hasCode = false;

    QString quoteType; // ">" –∏–ª–∏ ">^"
    QString linkUrl;
    QString emojiSpec; // custom-emoji://...

    for (const QString& t : tokens)
    {
        if (t == QStringLiteral("**"))
        {
            hasBold = true;
        }
        else if (t == QStringLiteral("__"))
        {
            hasUnderline = true;
        }
        else if (t == QStringLiteral("~~"))
        {
            hasStrike = true;
        }
        else if (t == QStringLiteral("||"))
        {
            hasSpoiler = true;
        }
        else if (t == QStringLiteral("^^"))
        {
            hasSup = true;
        }
        else if (t == QStringLiteral("`"))
        {
            hasCode = true;
        }
        else if (t == QStringLiteral(">") || t == QStringLiteral(">^"))
        {
            quoteType = t;
        }
        else if (t.startsWith(QStringLiteral("custom-emoji://")))
        {
            emojiSpec = t;
        }
        else if (t.contains(QStringLiteral("://")))
        {
            linkUrl = t;
        }
    }

    QString text = segment;

    // Custom emoji: –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—à –ø—Å–µ–≤–¥–æ-markdown [X](emoji:<id>?<size>)
    if (!emojiSpec.isEmpty())
    {
        const QString kPrefix = QStringLiteral("custom-emoji://");
        QString core = emojiSpec.mid(kPrefix.size()); // <document_id>?size
        text = QStringLiteral("[%1](emoji:%2)").arg(text, core);
    }

    // –°—Å—ã–ª–∫–∞: [text](url)
    if (!linkUrl.isEmpty())
    {
        text = QStringLiteral("[%1](%2)").arg(text, linkUrl);
    }

    // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Å—Ç–∏–ª–∏. –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫, —á—Ç–æ–±—ã –±—ã–ª–∞ —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å.
    if (hasCode)
    {
        text = QStringLiteral("`%1`").arg(text);
    }
    if (hasBold)
    {
        text = QStringLiteral("**%1**").arg(text);
    }
    if (hasUnderline)
    {
        text = QStringLiteral("__%1__").arg(text);
    }
    if (hasStrike)
    {
        text = QStringLiteral("~~%1~~").arg(text);
    }
    if (hasSpoiler)
    {
        text = QStringLiteral("||%1||").arg(text);
    }
    if (hasSup)
    {
        text = QStringLiteral("^^%1^^").arg(text);
    }

    // –¶–∏—Ç–∞—Ç—ã ‚Äì –Ω–∞—Ä—É–∂–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å
    if (quoteType == QStringLiteral(">"))
    {
        text = QStringLiteral(">%1<").arg(text);
    }
    else if (quoteType == QStringLiteral(">^"))
    {
        text = QStringLiteral(">^%1<^").arg(text);
    }

    return text;
}

} // end anonymous namespace

void TelegramFormatter::formatAndCopyToClipboard(const QString& markdownText)
{
    const QList<QPair<QRegularExpression, QString>> rules = {
        {QRegularExpression("```(\\w*)\\r?\\n?([\\s\\S]*?)\\r?\\n?```"),   "code-block"},
        {    QRegularExpression("\\[([^\\]]+)\\]\\(emoji:([^\\)]+)\\)"), "custom-emoji"},
        {                    QRegularExpression(">\\^([\\s\\S]*?)<\\^"),           ">^"},
        {                          QRegularExpression(">([\\s\\S]*?)<"),            ">"},
        {                        QRegularExpression("`([^`\\r\\n]+?)`"),            "`"},
        {                       QRegularExpression("\\*\\*(.*?)\\*\\*"),           "**"},
        {                               QRegularExpression("__(.*?)__"),           "__"},
        {                               QRegularExpression("~~(.*?)~~"),           "~~"},
        {                       QRegularExpression("\\|\\|(.*?)\\|\\|"),           "||"},
        {                       QRegularExpression("\\^\\^(.*?)\\^\\^"),           "^^"},
        {QRegularExpression("\\[([^\\]]+)\\]\\((?!emoji:)([^\\)]+)\\)"),         "link"}
    };

    auto result = parseText(markdownText, rules);
    QString cleanText = result.first;
    QList<FinalTag> finalTags = result.second;

    std::sort(finalTags.begin(), finalTags.end());

    QByteArray tagsBinary;
    QDataStream stream(&tagsBinary, QIODevice::WriteOnly);
    stream.setByteOrder(QDataStream::BigEndian);

    stream << (quint32)finalTags.size();

    for (const auto& tag : finalTags)
    {
        const QString& tagContent = tag.tagData;
        QByteArray tagData;
        for (const QChar& ch : tagContent)
        {
            ushort u = ch.unicode();
            tagData.append(static_cast<char>(u >> 8));
            tagData.append(static_cast<char>(u & 0xFF));
        }
        stream << (quint32)tag.position;
        stream << (quint32)tag.length;
        stream << (quint32)tagData.size();
        stream.writeRawData(tagData.constData(), tagData.size());
    }

    QMimeData* mimeData = new QMimeData();
    mimeData->setData("application/x-td-field-text", cleanText.toUtf8());
    mimeData->setData("application/x-td-field-tags", tagsBinary);
    mimeData->setText(cleanText);

    QGuiApplication::clipboard()->setMimeData(mimeData);
}

QString TelegramFormatter::fromTelegramClipboardToPseudoMarkdown(const QMimeData* mimeData)
{
    if (mimeData == nullptr)
    {
        return {};
    }

    QByteArray textBytes;
    if (mimeData->hasFormat("application/x-td-field-text"))
    {
        textBytes = mimeData->data("application/x-td-field-text");
    }
    else if (mimeData->hasText())
    {
        return mimeData->text();
    }
    else
    {
        return {};
    }

    const QString kCleanText = QString::fromUtf8(textBytes);

    if (!mimeData->hasFormat("application/x-td-field-tags"))
    {
        return kCleanText;
    }

    const QByteArray kTagsBinary = mimeData->data("application/x-td-field-tags");
    const QVector<TagRecord> kRawTags = parseTelegramTagsBinary(kTagsBinary);
    if (kRawTags.isEmpty())
    {
        return kCleanText;
    }

    // –†–∞–∑–±–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã –ø–æ –≤—Å–µ–º –≥—Ä–∞–Ω–∏—Ü–∞–º —Ç–µ–≥–æ–≤
    QSet<qsizetype> breakpoints;
    breakpoints.insert(0);
    breakpoints.insert(kCleanText.size());

    for (const TagRecord& rec : kRawTags)
    {
        if (rec.position >= 0 && rec.position <= kCleanText.size())
        {
            breakpoints.insert(rec.position);
        }
        const qsizetype kEndPos = rec.position + rec.length;
        if (kEndPos >= 0 && kEndPos <= kCleanText.size())
        {
            breakpoints.insert(kEndPos);
        }
    }

    QList<qsizetype> points = breakpoints.values();
    std::sort(points.begin(), points.end());
    if (points.size() < 2)
    {
        return kCleanText;
    }

    QString result;
    result.reserve(kCleanText.size());

    for (int i = 0; i < points.size() - 1; ++i)
    {
        const qsizetype kStart = points[i];
        const qsizetype kEnd = points[i + 1];
        if (kStart >= kEnd)
        {
            continue;
        }

        const QString kSegment = kCleanText.mid(kStart, kEnd - kStart);

        // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Ç–æ–∫–µ–Ω—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–∫—Ä—ã–≤–∞—é—Ç —ç—Ç–æ—Ç —Å–µ–≥–º–µ–Ω—Ç —Ü–µ–ª–∏–∫–æ–º
        QStringList tokens;
        for (const TagRecord& rec : kRawTags)
        {
            const qsizetype kRecStart = rec.position;
            const qsizetype kRecEnd = rec.position + rec.length;

            if (kRecStart <= kStart && kRecEnd >= kEnd)
            {
                const QStringList kParts = rec.tagContent.split('\\', Qt::SkipEmptyParts);
                for (const QString& p : kParts)
                {
                    if (!p.isEmpty())
                    {
                        tokens.append(p);
                    }
                }
            }
        }

        if (tokens.isEmpty())
        {
            result.append(kSegment);
        }
        else
        {
            // –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã, —á—Ç–æ–±—ã –Ω–µ —Ä–∞–∑–¥—É–≤–∞—Ç—å —Ä–∞–∑–º–µ—Ç–∫—É
            QStringList uniqueTokens;
            QSet<QString> seen;
            for (const QString& t : std::as_const(tokens))
            {
                if (!seen.contains(t))
                {
                    seen.insert(t);
                    uniqueTokens.append(t);
                }
            }

            result.append(applyTokensToSegment(kSegment, uniqueTokens));
        }
    }

    return result;
}

–≤ –≤–∏–¥–∂–µ—Ç–µ:
    // –ü–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º –≤—Å—Ç–∞–≤–∫—É –≤ –ø–æ–ª—è—Ö Telegram-–ø–æ—Å—Ç–æ–≤, —á—Ç–æ–±—ã —É–º–µ—Ç—å –ø–æ–Ω–∏–º–∞—Ç—å
    // —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –±—É—Ñ–µ—Ä–∞ –æ–±–º–µ–Ω–∞ Telegram (application/x-td-field-*).
    ui->postTgMp4Edit->installEventFilter(this);
    ui->postTgMkvEdit->installEventFilter(this);


bool TemplateEditor::eventFilter(QObject* watched, QEvent* event)
{
    const bool kIsTgPostEdit = watched == ui->postTgMp4Edit || watched == ui->postTgMkvEdit;

    if (!kIsTgPostEdit)
    {
        return QDialog::eventFilter(watched, event);
    }

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Å—Ç–∞–≤–∫—É (Ctrl+V, –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é –∏ —Ç.–ø.)
    if (event->type() == QEvent::KeyPress)
    {
        auto* keyEvent = dynamic_cast<QKeyEvent*>(event);
        if (keyEvent->matches(QKeySequence::Paste))
        {
            const QMimeData* mime = QApplication::clipboard()->mimeData();
            const QString kText = TelegramFormatter::fromTelegramClipboardToPseudoMarkdown(mime);

            if (!kText.isEmpty())
            {
                if (watched == ui->postTgMp4Edit)
                {
                    ui->postTgMp4Edit->insertPlainText(kText);
                }
                else if (watched == ui->postTgMkvEdit)
                {
                    ui->postTgMkvEdit->insertPlainText(kText);
                }   
                return true; // –º—ã –æ–±—Ä–∞–±–æ—Ç–∞–ª–∏ –≤—Å—Ç–∞–≤–∫—É
            }
        }
    }
    // Note: QEvent does not have a 'Paste' type; handle paste from QMimeData (e.g., QTextEdit paste event) via
    // QEvent::Clipboard or override insertFromMimeData if needed.
    else if (event->type() == QEvent::Clipboard)
    {
        const QMimeData* mime = QApplication::clipboard()->mimeData();
        const QString kText = TelegramFormatter::fromTelegramClipboardToPseudoMarkdown(mime);

        if (!kText.isEmpty())
        {
            if (watched == ui->postTgMp4Edit)
            {
                ui->postTgMp4Edit->insertPlainText(kText);
            }
            else if (watched == ui->postTgMkvEdit)
            {
                ui->postTgMkvEdit->insertPlainText(kText);
            }
            return true;
        }
    }

    return QDialog::eventFilter(watched, event);
}

–Ω–µ –Ω–∞—à–µ–ª –≥–¥–µ –≤ –ø—Ä–æ–µ–∫—Ç–µ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Ñ—É–Ω–∫—Ü–∏—è protected:
    bool eventFilter(QObject* watched, QEvent* event) override;
–ù–æ –ø–æ–≤–µ–¥–µ–Ω–∏–µ —Ç–∞–∫–æ–µ, —á—Ç–æ –Ω–∞ ctrl+V –≤—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è —Ç–µ–∫—Å—Ç –∏–∑ –ø–µ—Ä–≤–æ–≥–æ mime —Ñ–æ—Ä–º–∞—Ç–∞, –±–µ–∑ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ç–µ–≥–æ–≤, –∞ –Ω–∞ –≤—Å—Ç–∞–≤–∫—É —á–µ—Ä–µ–∑ –ø—Ä–∞–≤—É—é –∫–Ω–æ–ø–∫—É –º—ã—à–∏ plain-text —Ç–µ–ª–µ–≥—Ä–∞–º–∞, —Ç–æ –µ—Å—Ç—å —Ñ–æ–ª–ª–±—ç–∫, –≥–¥–µ –Ω–∞–ø—Ä–∏–º–µ—Ä —Å—Å—ã–ª–∫–∏ –≤—Å—Ç–∞–≤–ª—è—é—Ç—Å—è –≤ —Å–∫–æ–±–∫–∞—Ö —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª –æ—Ç —Å–ª–æ–≤–∞ –∫—É–¥–∞ –æ–Ω–∏ –±—ã–ª–∏ –∑–∞—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã, –∏ —É –º–µ–Ω—è —ç–º–æ–¥–∑–∏ –Ω–∞–ø—Ä–∏–º–µ—Ä –Ω–µ –≤—Å—Ç–∞–≤–ª—è—é—Ç—Å—è

–≤–∏–¥–∏—à—å –ª–∏ —Ç—ã –ø—Ä–∏—á–∏–Ω—É?


QString TelegramFormatter::fromTelegramClipboardToPseudoMarkdown(const QMimeData* mimeData)
{
    if (mimeData == nullptr)
    {
        return {};
    }

    QByteArray textBytes;
    if (mimeData->hasFormat("application/x-td-field-text"))
    {
        textBytes = mimeData->data("application/x-td-field-text");
    }
    else if (mimeData->hasText())
    {
        return mimeData->text();
    }
    else
    {
        return {};
    }

    const QString kCleanText = QString::fromUtf8(textBytes);

    if (!mimeData->hasFormat("application/x-td-field-tags"))
    {
        return kCleanText;
    }

    const QByteArray kTagsBinary = mimeData->data("application/x-td-field-tags");
    const QVector<TagRecord> kRawTags = parseTelegramTagsBinary(kTagsBinary);
    if (kRawTags.isEmpty())
    {
        return kCleanText;
    }

    // –†–∞–∑–±–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã –ø–æ –≤—Å–µ–º –≥—Ä–∞–Ω–∏—Ü–∞–º —Ç–µ–≥–æ–≤
    QSet<qsizetype> breakpoints;
    breakpoints.insert(0);
    breakpoints.insert(kCleanText.size());

    for (const TagRecord& rec : kRawTags)
    {
        if (rec.position >= 0 && rec.position <= kCleanText.size())
        {
            breakpoints.insert(rec.position);
        }
        const qsizetype kEndPos = rec.position + rec.length;
        if (kEndPos >= 0 && kEndPos <= kCleanText.size())
        {
            breakpoints.insert(kEndPos);
        }
    }

    QList<qsizetype> points = breakpoints.values();
    std::sort(points.begin(), points.end());
    if (points.size() < 2)
    {
        return kCleanText;
    }

    QString result;
    result.reserve(kCleanText.size());

    for (int i = 0; i < points.size() - 1; ++i)
    {
        const qsizetype kStart = points[i];
        const qsizetype kEnd = points[i + 1];
        if (kStart >= kEnd)
        {
            continue;
        }

        const QString kSegment = kCleanText.mid(kStart, kEnd - kStart);

        // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Ç–æ–∫–µ–Ω—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–∫—Ä—ã–≤–∞—é—Ç —ç—Ç–æ—Ç —Å–µ–≥–º–µ–Ω—Ç —Ü–µ–ª–∏–∫–æ–º
        QStringList tokens;
        for (const TagRecord& rec : kRawTags)
        {
            const qsizetype kRecStart = rec.position;
            const qsizetype kRecEnd = rec.position + rec.length;

            if (kRecStart <= kStart && kRecEnd >= kEnd)
            {
                const QStringList kParts = rec.tagContent.split('\\', Qt::SkipEmptyParts);
                for (const QString& p : kParts)
                {
                    if (!p.isEmpty())
                    {
                        tokens.append(p);
                    }
                }
            }
        }

        if (tokens.isEmpty())
        {
            result.append(kSegment);
        }
        else
        {
            // –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã, —á—Ç–æ–±—ã –Ω–µ —Ä–∞–∑–¥—É–≤–∞—Ç—å —Ä–∞–∑–º–µ—Ç–∫—É
            QStringList uniqueTokens;
            QSet<QString> seen;
            for (const QString& t : std::as_const(tokens))
            {
                if (!seen.contains(t))
                {
                    seen.insert(t);
                    uniqueTokens.append(t);
                }
            }

            result.append(applyTokensToSegment(kSegment, uniqueTokens));
        }
    }

    return result;
}
